= Quick Introduction to Ferret

The simplest way to use Ferret is through the Ferret::Index::Index class.
Start by including the Ferret module.

| Ruby
  require 'ferret'
  include Ferret

| Lisp
  (asdf:oos 'asdf:load-op '#:montezuma)
  (in-package #:montezuma) ; For now

=== Creating an index

To create an in memory index is very simple;
  
| Ruby
  index = Index::Index.new()

| Lisp
  (defparameter *index* (make-instance 'index))

  
To create a persistent index;

| Ruby
  index = Index::Index.new(:path => '/path/to/index')

| Lisp
  (defparameter *index* (make-instance 'index
				       :path "/path/to/index"))

Both of these methods create new Indexes with the StandardAnalyzer. An
analyzer is what you use to divide the input data up into tokens which you can
search for later. If you'd like to use a different analyzer you can specify it
here, eg;

| Ruby
  index = Index::Index.new(:path => '/path/to/index',
                           :analyzer => WhiteSpaceAnalyzer.new)

| Lisp
  (defparameter *index* (make-instance 'index
				       :path "/path/to/index"
				       :analyzer (make-instance 'whitespace-analyzer)))


For more options when creating an Index refer to Ferret::Index::Index.

=== Adding Documents

To add a document you can simply add a string or an array of strings. This will
store all the strings in the "" (ie empty string) field (unless you specify the
default field when you create the index).

| Ruby
  index << "This is a new document to be indexed"
  index << ["And here", "is another", "new document", "to be indexed"]

| Lisp
  (add-document-to-index *index* "This is a new document to be indexed")
  (add-document-to-index *index* #("And here" "is another" "new document" "to be indexed"))

  
But these are pretty simple documents. If this is all you want to index you
could probably just use SimpleSearch. So let's give our documents some fields;

| Ruby
  index << {:title => "Programming Ruby", :content => "blah blah blah"}
  index << {:title => "Programming Ruby", :content => "yada yada yada"}

| Lisp
  (add-document-to-index *index* '(("title" . "Programming Ruby")
				   ("content" . "blah blah blah")))
  (add-document-to-index *index* '(("title" . "Programming Ruby")
				   ("content" . "yada yada yada")))

Or if you are indexing data stored in a database, you'll probably want to
store the id;

| Ruby
  index << {:id => row.id, :title => row.title, :date => row.date}

| Lisp
  (add-document-to-index *index* `(("id"    . ,(id row))
				   ("title" . ,(title row))
				   ("date"  . ,(date row))))

The methods above while store all of the input data as well tokenizing and
indexing it. Sometimes we won't want to tokenize (divide the string into
tokens) the data. For example, we might want to leave the title as a complete
string and only allow searchs for that complete string. Sometimes we won't
want to store the data as it's already stored in the database so it'll be a
waste to store it in the index. Or perhaps we are doing without a database and 
using Ferret to store all of our data, in which case we might not want to
index it. For example, if we are storing images in the index, we won't want to
index them. All of this can be done using Ferret's Ferret::Document module.
eg;

| Ruby
  include Ferret::Document
  doc = Document.new
  doc << Field.new("id",    row.id,    Field::Store::NO,  Field::Index::UNTOKENIZED)
  doc << Field.new("title", row.title, Field::Store::YES, Field::Index::UNTOKENIZED)
  doc << Field.new("data",  row.data,  Field::Store::YES, Field::Index::TOKENIZED)
  doc << Field.new("image", row.image, Field::Store::YES, Field::Index::NO)
  index << doc

| Lisp
  (let ((doc (make-instance 'document)))
     (add-field doc (make-field "id"    (id row)    :stored NIL :index :untokenized))
     (add-field doc (make-field "title" (title row) :stored T   :index :untokenized))
     (add-field doc (make-field "data"  (data row)  :stored T   :index :tokenized))
     (add-field doc (make-field "image" (image row) :stored T   :index NIL))
     (add-document-to-index *index* doc))


You can also compress the data that you are storing or store term vectors with
the data. Read more about this in Ferret::Document::Field.

=== Searching

Now that we have data in our index, how do we actually use this index to
search the data? The Index offers two search methods, Index#search and
Index#search_each. The first method returns a Ferret::Index::TopDocs object.
The second we'll show here. Lets say we wanted to find all documents with the
phrase "quick brown fox" in the content field. We'd write;

| Ruby
  index.search_each('content:"quick brown fox"') do |doc, score|
    puts "Document #{doc} found with a score of #{score}"
  end

| Lisp -- doesn't work
  (dolist (result (enumerate (search-each *index* "content:\"quick brown fox\"")))
    (destructuring-bind (doc score) result
      (format T "~&Document ~S found with score of ~S" doc score)))

But "fast" has a pretty similar meaning to "quick" and we don't mind if the
fox is a little red. Also, the phrase could be in the title so we'll search
there as well. So we could expand our search like this;

| Ruby
  index.search_each('title|content:"quick|fast brown|red fox"') do |doc, score|
    puts "Document #{doc} found with a score of #{score}"
  end

| Lisp -- doesn't work
  (dolist (result (enumerate (search-each *index* "content:\"quick|fast brown| red box\"")))
    (destructuring-bind (doc score) result
      (format T "~&Document ~S found with score of ~S" doc score)))

What if we want to find all documents entered on or after 5th of September,
2005 with the words "ruby" or "rails" in any field. We could type something like;

| Ruby
  index.search_each('date:( >= 20050905) *:(ruby OR rails)') do |doc, score|
    puts "Document #{doc} found with a score of #{score}"
  end

| Lisp -- doesn't work
  (dolist (result (enumerate (search-each *index* "date:( >= 20050905 *:(ruby OR rails)")))
    (destructuring-bind (doc score) result
      (format T "~&Document ~S found with score of ~S" doc score)))

Ferret has quite a complex query language. To find out more about Ferret's
query language, see Ferret::QueryParser. You can also construct even more
complex queries like Ferret::Search::Spans by hand. See Ferret::Search::Query
for more information.

=== Accessing Documents

You may have noticed that when we run a search we only get the document number
back. By itself this isn't much use to us. Getting the data from the index is
very straightforward. For example if we want the title field form the 3rd
document type;
  
| Ruby
  index[2]["title"]

| Lisp
  (document-field (get-document *index* 2) "title")

NOTE: documents are indexed from 0.

The default field is an empty string when you use the simple string document so
to access those strings you'll have type;

| Ruby
  index << "This is a document"
  index[0][""]

| Lisp
  (add-document-to-index *index* "This is a document")
  (document-field (get-document *index* 0) "")

Let's go back to the database example above. If we store all of our documents
with an id then we can access that field using the id. As long as we called
our id field "id" we can do this

| Ruby
  id = "89721347"
  index[id]["title"]

| Lisp
  (let ((id "89721347"))
    (document-field (get-document *index* id) "title"))

If however we called our id field "key" we'll have to do this;

| Ruby
  id = Index::Term.new("key", "89721347")
  index[id]["title"]

| Lisp
  (let ((id (make-term "key" "89721347")))
    (document-field (get-document *index* id) "title"))

Pretty simple huh? You should note though that if there are more then one
document with the same *id* or *key* then only the first one will be returned
so it is probably better that you ensure the key is unique somehow. (Ferret
cannot do that for you)


=== Modifying and Deleting Documents

What if we want to change the data in the index. Ferret doesn't actually let
you change the data once it is in the index. But you can delete documents so
the standard way to modify data is to delete it and re-add it again with the
modifications made. It is important to note that when doing this the documents
will get a new document number so you should be careful not to use a document
number after the document has been deleted. Here is an examle of modifying a
document;

  index << {:title => "Programing Rbuy", :content => "blah blah blah"}
  doc_num = nil
  index.search('title:"Programing Rbuy"') {|doc, score| doc_num = doc}
  return unless doc_num
  doc = index[doc_num]
  index.delete(doc_num)

  # modify doc
  doc["title"] = "Programming Ruby"

  index << doc

Again, we can use the the id field as above. This time though every document
that matches the id will be deleted. Again, it is probably a good idea if you
somehow ensure that your *ids* are kept unique.

| Ruby
  id = "23453422"
  index.delete(id)

| Lisp
  (let ((id "23453422"))
    (delete *index* id))

Or;

| Ruby
  id = Index::Term.new("key", "23452345")
  index.delete(id)

| Lisp
  (let ((id (make-term "key" "23452345")))
    (delete *index* id))
  
=== Onwards

This is just a small sampling of what Ferret allows you to do.  Ferret, like
Lucene, is designed to be extended, and allows you to construct your own query
types, analyzers, and so on. Future versions of Ferret will contain more of
these, as well as instructions for how to subclass the base modules to create
your own. For now you can look in the following places for more documentation;

* Ferret::Analysis: for more information on how the data is processed when it
  is tokenized. There are a number of things you can do with your data such as
  adding stop lists or perhaps a porter stemmer. There are also a number of
  analyzers already available and it is almost trivial to create a new one
  with a simple regular expression.

* Ferret::Search: for more information on querying the index. There are a
  number of already available queries and it's unlikely you'll need to create
  your own. You may however want to take advantage of the sorting or filtering
  abilities of Ferret to present your data the best way you see fit.

* Ferret::Document: to find out how to create documents. This part of Ferret
  is relatively straightforward. The main thing that we haven't gone into here
  is the use of term vectors. These allow you to store and retrieve the
  positions and offsets of the data which can be very useful in document
  comparison amoung other things.  == More information

* Ferret::QueryParser: if you want to find out more about what you can do with
  Ferret's Query Parser, this is the place to look. The query parser is one
  area that could use a bit of work so please send your suggestions.

* Ferret::Index: for more advanced access to the index you'll probably want to
  use the Ferret::Index::IndexWriter and Ferret::Index::IndexReader. This is
  the place to look for more information on them.

* Ferret::Store: This is the module used to access the actual index storage
  and won't be of much interest to most people.
